using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace MyFirstCSharp
{
    public partial class Chap26_2sComplement : Form
    {
        public Chap26_2sComplement()
        {
            InitializeComponent();
        }

        private void btnInt_Click(object sender, EventArgs e)
        {
            /*
                - 앞의 Fibonacci 수열에서 49 를 입력 시 int 자료형 리스트의 값 1134904170 + 183611903 = -132375223 인 이유
                  int 자료형은 4Byte의 메모리 공간이 할당  (4Byte = 8Bit * 4)
                  
                  Bit 0, 1의 상태를 담을 수 있는 메모리의 가장 작은 단위

                - 왜 1Byte가 8Bit 인가
                  너무 작은 단위로 관리를 하면 관리 범위가 커지기 때문에 8Bit를 1Byte 로 관리를 해서 메모리를 나타내는 최소단위로 정하자
                - 숫자를 처리하는 데이터 자료형 : 1Byte로 표현할 수 있는 숫자의 최대 크기 : 11111111 -> 10진수 변환 시 255
             */

            int iValue1 = 1134903170;
            int iValue2 = 183611903;
            int iResult = iValue1 + iValue2; // 1134903170 + 183611903
            MessageBox.Show(iResult.ToString());

            // int 4바이트를 담을 수 있는 자료형(32Bit)
            // [1111 1111] [1111 1111] [1111 1111] [1111 1111] = 4294967295
            // 32Bit 로 표현할 수 있는 최대 정수 (0 ~ 4294967295) . 음수를 포함하지 않는 최대 정수

            // 양수만 담을 수 있는 32Bit 정수 자료형
            uint uIValue = 4294967295;
            uIValue = uint.MaxValue; // 32Bit 양수 자료 최대 값 4294967295
            uIValue = uint.MinValue; // 32Bit 양수 자료 최소 값 0

            // 하지만 int 는 양과 음의 수로 표현하므로 최대 최소 값의 범위가 이동
            iResult = int.MinValue; // 32Bit 음수 포함 자료 최소값 : -2147483648
            iResult = int.MaxValue; // 32Bit 음수 포함 자료 최대값 : 2147483647 (왜 -와 + 의 크기가 다를까 0을 양수로 생각하기 때문)

            uIValue = 2147483647 + 2147483648; // 4294967295

            // int 자료형 구조는 똑같이 4294967295의 범위를 담을 수 있는데
            // 다만 -부터 시작하여 절반을 나눠 가지므로 -2147483648 ~ 2147483647가 4294967295의범위가 된다.

            // uint 에서 (양수만 관리하는 자료형)
            // 0을 2진수로 표현( unit 의 최소값)
            // 0000 0000 0000 0000 0000 0000 0000 0000  : 0 * 32 있는 2진수가 0의 값이 된다. 

            // int 의 경우 가장 앞자리 bit 0, 1을 음수와 양수로 사용
            // int 의 경우 최소값 -2147483648
            // 2진수로 표현
            // 1000 0000 0000 0000 0000 0000 0000 0000 : -2147483648
            // 1000 0000 0000 0000 0000 0000 0000 0001 : -2147483647
            // 1000 0000 0000 0000 0000 0000 0000 0010 : -2147483646
            // 1000 0000 0000 0000 0000 0000 0000 0011 : -2147483645

            // 1134903170 + 1836311903 = 2971215073
            // 이진법으로 변환
            // 1011 0001 0001 1001 0010 0100 1110 0001

            // int의 경우 최소값에서 증가한 정수의 수로 확인하므로
            // 0011 0001 0001 1001 0010 0100 1110 0001 : 823731425 만큼 증가했다고 판단
            // -2147483648 +  823731425 = -1,323,752,223라는 결과가 나온다.

            // 양수와 음수를 표현하는 2의 보수법
            // 부호(양수/음수)가 있는 숫자 자료형에서 2진수 데이터를 음수로 변환하는 알고리즘
            // ex) int의 최대값인 2147483648을 2의 보수법 알고리즘으로 int 가 인식하는 음수 2진수를 만들어보자 
            //  0111 1111 1111 1111 1111 1111 1111 1111
            // 1) 1은 0으로, 0은 1으로 반전
            // 1000 0000 0000 0000 0000 0000 0000 0000
            // 2) 마지막 수를 1 더하기
            // 1000 0000 0000 0000 0000 0000 0000 0001

            // 1000 0000 0000 0000 0000 0000 0000 0000 : -2147483648
            // 1000 0000 0000 0000 0000 0000 0000 0001 : -2147483647

        }
    }
}
